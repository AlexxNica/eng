---
title: Joyent Engineering Guide
markdown2extras: wiki-tables, code-friendly
---

# This Guide

**Note: Despite the tone below, this guide is still a work in progress.
Everything here is subject to change as we discuss it with the team.**

This document describes standards and best practices for software development
at Joyent. These standards are intended to maintain product quality and to
provide consistency across codebases to help all engineers understand
unfamiliar parts of the system. This latter goal is important to encourage all
engineers to feel comfortable diving into all parts of the system.

It's important to remember that all situations are unique, so rules should not
be followed blindly. However, these guidelines represent the best practices
agreed upon by the team. If you feel it necessary to diverge from them, that's
okay, but be prepared to explain why.

# Conventions

Services implementing an API are referred to as APIs. For example, "MAPI"
denotes the service implementing the MAPI API.

# Repository overview

These guidelines cover naming, structure, and processes around repositories.
A template repository is included in this repo so you can quickly get something
working that follows these guidelines.

## Repository naming

For repositories representing an API, the repo name that matches how the API is
discussed (spoken, chatted and emailed) means you'll get the repo name right on
first guess. If you can get away with it, a repo named after the abbreviate API
name is best. For example:
    
    Network API -> NAPI -> napi.git   # Good.
                        -> NAPI.git   # Whoa! Capital letters are crazy here.
                        -> network-api.git   # Less good.
                        -> network_api.git   # Even less good.

(So why isn't this repo called "bapi.git"? Because this repo will more often be
called the "Boilerplate API" when discussed -- no need to popularize "BAPI".)

## Rule #1: FCS Quality All the Time

In general, use the "master" branch for development and releases. **"master"
should be FCS (First Customer Ship) quality at all times.** Although releases
are technically cut from release-specific branches, these branches are not
expected to diverge significantly from "master" at the time the branch was cut
except for fixes backported after the cut. That is, development should not be
ongoing in the release branches.

When working on large features, it's tempting to use development branches that
eventually get integrated into master. Indeed, this is sometimes necessary.
However, it should be avoided when possible, as it means people are running dev
branches rather than "master", leading to a quality death spiral (QDS) as fewer
people actually run the mainline tree. Where possible, consider whether larger
projects can be split into reasonably-sized chunks that can individually be
integrated into "master" without breaking existing functionality. This allows
you to continue developing on "master" while still being able to commit
frequently.

## Language

New server-side projects should almost certainly use Node.js (with C/C++
components as needed). Consolidating onto one language makes it easier for
everyone to dig into other teams' projects as needed (for development as well as
debugging) and allows us to share code and tools.

## README

Every repository should have in its root a README.md restdown file that
describes the repo and covers:

* the name of the API or other component(s) contained in the repo and a brief
  description of what they do
* the JIRA project for this repo (and any additional instructions, like how JIRA
  components are used for this project)
* owners of the project
* the style and lint configurations used, any additional pre-commit checks, and
  any non-standard useful Makefile targets
* some overview of the structure of the project, potentially including
  descriptions of the subcomponents, directory structure, and basic design
  principles
* basic development workflow: how to run the code and start playing with it

It's strongly recommended to start with the template in this repo.

## Makefile

All repos should have a Makefile that defines at least the following targets:

* `all`: builds all intermediate objects (e.g., binaries, executables, docs,
  etc.). This should be the default target.
* `check-style`: checks all files for adherence to style (see below)
* `check-lint`: checks all files for adherence to lint (see below)
* `check`: checks all files for adherence to lint, style, and other
  repo-specific rules not described here.
* `clean`: removes all built files
* `docs`: builds documentation (restdown)
* `pbchk`: runs all checks and tests (possibly including checks not described
  here).
* `test`: runs the automated test suite

The `check` and `test` targets should fail if they find any 'check' violations
or failed tests. The `pbchk` target is intended to cover all pre-commit
checks. It should run successfully before any push to the repo. It should also
be part of the automated build. Any commit which introduces a pbchk failure
should be fixed immediately or backed out.

Some projects may require no additional targets because they consist only of
interpreted source code (e.g., JavaScript). For repos that generate an artifact
(e.g., a tarball), use the `release` target to build it.

## Coding style

Every repository must have a consistent coding style that is enforced by some
tool. Existing style-checking tools include:

* C: <https://github.com/joyent/illumos-joyent/blob/master/usr/src/tools/scripts/cstyle.pl>
* JavaScript: <http://github.com/davepacheco/jsstyle>

Both of these tools (which are 90% the same anyway) support overriding style
checks on a per-line basis (e.g., for literal regular expressions).

It's not necessary that all projects use the same style, though it's strongly
suggested to keep differences to a minimum (e.g., only hard vs. soft tabs and
tabstops). Feel free add options to the above tools to allow for such
flexibility, or to write new tools. All styles should limit line length to 80
columns.

Make target: "check-style"

## Lint

Every C repository must run lint and every JavaScript repository must run
<http://github.com/davepacheco/javascriptlint> and both must be lint-clean.
(Note that lint is not the same as style; lint covers objectively dangerous
patterns like undeclared variables, while style covers subjective conventions
like spacing.)

Both lint and javascriptlint are very configurable. Projects may choose to
enable and disable particular sets of checks as they deem inappropriate, and
most checks can be disabled on a per-line basis. As with style, it's
recommended that we minimize divergence between repositories.

Make target: "check-lint" 

## Testing

All repos should include a comprehensive automated test suite, preferably using
node-tap. Bug fixes and new features should not be integrated without
considering adding new tests.

Make target: "test"

## XXX Use restify

## XXX Managing dependencies

## XXX Commit comments

# XXX Using JIRA
## XXX Information to include

# XXX Observability tools
# XXX Developing on SmartOS? Setup-dev-environment tools
# XXX Upgrade tools
# XXX Documentation (design docs, big theory statements, etc.)
# XXX Checking in derived files
